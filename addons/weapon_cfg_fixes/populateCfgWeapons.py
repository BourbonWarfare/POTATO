from enum import Enum
import re
import os
import time
import datetime
import sys

WEAPON_TEMPLATE = """    class #classname {
        modes[] = {#Modes};
"""

MODE_TEMPLATE = """        class #InheritMode {
            burst = #Burst;
            aiRateOfFire = #RateOfFire;
            aiRateOfFireDistance = #ROFDist;
            minRange = #MinimumRange;
            minRangeProbab = #MinRangeProb;
            midRange = #MediumRange;
            midRangeProbab = #MidRangeProb;
            maxRange = #MaximumRange;
            maxRangeProbab = #MaxRangeProb;
        };"""

warnings = []


def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        ret = func(*args, **kwargs)
        print('Completed in', round(time.time() - start, 2), 'Seconds')
        return ret
    return wrapper


class ConfigData:
    weapons = {}
    new_modes = []

    def __init__(self):
        self.weapons = {}
        self.new_modes = []

    def add_mode(self, mode):
        self.new_modes.append(mode)

    def add_weapon(self, weapon, values):
        self.weapons[weapon] = values


class ClassData:
    def __init__(self):
        self.processed = False
        self.wrote = False
        self.baseClass = ""
        self.inheritClass = ""
        self.classDefinition = ""
        self.modeArr = []
        self.childClasses = []


def get_modes(weapon):
    """
    burst=-1
    aiRateOfFire = 5;
    aiRateOfFireDistance = 700;
    minRange=2;
    minRangeProbab=0.30000001;
    midRange=350;
    midRangeProbab=0.69999999;
    maxRange=500;
    maxRangeProbab=0.050000001;
    """

    # key words to check for. If none of these are present, we will ignore the mode
    mode_check = ['burst',
                  'reloadTime',  # for handling an issue regarding inheritance
                  'aiRateOfFire',
                  'aiRateOfFireDistance',
                  'minRange', 'minRangeProbab',
                  'midRange', 'midRangeProbab',
                  'maxRange', 'maxRangeProbab']

    class ReadState(Enum):
        SEARCHING_CLASSES = 0
        READING_NAME = 1
        READING_DATA = 2

    state = ReadState.SEARCHING_CLASSES
    bracket_count = 0
    bracket_count_temp = 0
    count = 0
    internal_class_def = []

    name = ""
    definition = ""

    for c in weapon.classDefinition:
        if c == '{':
            bracket_count += 1
        elif c == '}':
            bracket_count -= 1

        if state == ReadState.SEARCHING_CLASSES:
            if c == "class"[count]:
                count += 1
            else:
                count = 0

            if count == len("class"):
                state = ReadState.READING_NAME
                count = 0
        elif state == ReadState.READING_NAME:
            if c == '{':
                state = ReadState.READING_DATA
                bracket_count_temp = bracket_count - 1
            elif c != ';':
                name += c
            else:
                name = ""
                state = ReadState.SEARCHING_CLASSES
        elif state == ReadState.READING_DATA:
            if bracket_count == bracket_count_temp:
                internal_class_def.append([name, definition])
                state = ReadState.SEARCHING_CLASSES
                definition = ""
                name = ""
                bracket_count_temp = 0
            else:
                definition += c

    return_class_def = []
    for classDef in internal_class_def:
        if any(re.search(r"\b" + re.escape(check) + r"\b", classDef[1]) for check in mode_check):
            return_class_def.append(classDef[0].strip().strip('\n'))
    return return_class_def


@timer
def write_to_file(output, config):
    now = datetime.datetime.now()
    file = open(output, 'w')
    file.write("// Generated by script on date -> " + now.strftime("%Y-%m-%d - %H:%M") + "\n")
    file.write("class Mode_SemiAuto;\n")
    file.write("class Mode_Burst;\n")
    file.write("class Mode_FullAuto;\n")
    file.write("class CfgWeapons {\n")
    file.write(config)
    file.write("};\n\n")
    file.close()


def is_suitable_parent(weapon):
    suitable = False
    if weapon.childClasses:
        for child in weapon.childClasses:
            if get_modes(child):
                return True
            else:
                suitable |= is_suitable_parent(child)
    return suitable


def remove_bad_lines(mode_str):
    mode_list = [e + '\n' for e in mode_str.split('\n') if e]
    new_mode_list = []
    for line in mode_list:
        if not ('-1' in line):
            new_mode_list.append(line)
    if len(new_mode_list) > 2:  # class definition start, and end bracket == 2
        return ''.join(new_mode_list)
    else:
        return ""


def write_modes(weapon, config_str, config_file):
    global warnings
    if weapon.wrote:
        return config_str

    weapon.modeArr = get_modes(weapon)
    weapon.wrote = True
    if not weapon.modeArr and is_suitable_parent(weapon):
        if weapon.inheritClass:
            return "    class " + weapon.baseClass + ": " + weapon.inheritClass + " {};\n"
        else:
            return "    class " + weapon.baseClass + ";\n"
    elif not weapon.modeArr:
        return ""

    weapon_str = WEAPON_TEMPLATE
    weapon_modes_str = ""
    if not ((weapon.baseClass + ": " + weapon.inheritClass) in config_file.weapons):
        warnings.append(
            weapon.baseClass + ": " + weapon.inheritClass + " not defined in weapons.txt! Nothing generated")
        return ""

    weapon_value_arr = config_file.weapons[weapon.baseClass + ": " + weapon.inheritClass]
    all_new_modes = ""
    new_modes = ""
    for mode in config_file.new_modes:
        mode_name = mode[0]
        mode_def = mode[1]
        mode_index = mode[2]
        if mode_index >= len(weapon_value_arr):
            break

        previous_all_new_mode = all_new_modes
        all_new_modes += '"' + mode_name.split(':', 1)[0] + '",'

        mode_data = weapon_value_arr[mode_index]
        while len(mode_data) < 9:
            mode_data.append('-1')

        mode_str = MODE_TEMPLATE
        mode_str = mode_str.replace('#Burst', mode_data[0])
        mode_str = mode_str.replace('#RateOfFire', mode_data[1])
        mode_str = mode_str.replace('#ROFDist', mode_data[2])
        mode_str = mode_str.replace('#MinimumRange', mode_data[3])
        mode_str = mode_str.replace('#MinRangeProb', mode_data[4])
        mode_str = mode_str.replace('#MediumRange', mode_data[5])
        mode_str = mode_str.replace('#MidRangeProb', mode_data[6])
        mode_str = mode_str.replace('#MaximumRange', mode_data[7])
        mode_str = mode_str.replace('#MaxRangeProb', mode_data[8])
        mode_str = mode_str.replace('#InheritMode', mode_name.replace('InheritMode', weapon.modeArr[0].split(':', 1)[0]))

        mode_str = remove_bad_lines(mode_str)
        mode_str_lines = [e + '\n' for e in mode_str.split('\n') if e]
        if not mode_str:
            all_new_modes = previous_all_new_mode
        elif mode_def:
            mode_def = mode_def.replace('{', '').replace('}', '')
            mode_def_arr = mode_def.split(';')
            for definition in mode_def_arr:
                mode_str_lines.insert(len(mode_str_lines) - 1, '            ' + definition + ';\n')

        if mode_str:
            mode_str_lines.insert(len(mode_str_lines) - 1, '            ' + 'showToPlayer=0;\n')
            mode_str = ''.join(mode_str_lines)

        new_modes += mode_str

    prev_modes = ""
    if all_new_modes:
        for mode in weapon.modeArr:
            mode_type = mode.split(':', 1)[0]
            weapon_modes_str += '"' + mode_type + '",'

            mode_str = MODE_TEMPLATE
            mode_str = mode_str.replace('#Burst', '-1')
            mode_str = mode_str.replace('#RateOfFire', '-1')
            mode_str = mode_str.replace('#ROFDist', '-1')
            mode_str = mode_str.replace('#MinimumRange', '-1')
            mode_str = mode_str.replace('#MinRangeProb', '0')
            mode_str = mode_str.replace('#MediumRange', '-1')
            mode_str = mode_str.replace('#MidRangeProb', '0')
            mode_str = mode_str.replace('#MaximumRange', '-1')
            mode_str = mode_str.replace('#MaxRangeProb', '0')
            mode_str = mode_str.replace('#Extra', '-1')
            mode_str = mode_str.replace('#InheritMode', mode)

            mode_str = remove_bad_lines(mode_str)
            prev_modes += mode_str

    weapon_str += prev_modes + new_modes

    weapon_str = weapon_str.replace('#classname', weapon.baseClass + ': ' + weapon.inheritClass)
    if not all_new_modes:
        weapon_modes_str = weapon_modes_str[:-1]

    if not weapon_modes_str:
        weapon_str_arr = [e + '\n' for e in weapon_str.split('\n') if e]
        weapon_str_arr.remove(weapon_str_arr[-1])
        weapon_str = ''.join(weapon_str_arr)
    else:
        weapon_str = weapon_str.replace('#Modes', weapon_modes_str + all_new_modes[:-1])
    weapon_str += "    };\n\n"
    return weapon_str


@timer
def write_to_string(all_weapons, config_file):
    config_str = ""
    for weapon in all_weapons:
        config_str += write_modes(weapon, "", config_file)
    return config_str


def remove_duplicate_weapons(all_weapons, new_weapon_list):
    for weapon in all_weapons:
        for testWeapon in new_weapon_list:
            if testWeapon.baseClass == weapon.baseClass:
                new_weapon_list.remove(testWeapon)
    return new_weapon_list


def set_inheritance(all_weapons, weapon):
    if not weapon.inheritClass:
        return []
    for possible_base in all_weapons:
        if possible_base.baseClass == weapon.inheritClass:
            possible_base.childClasses.append(weapon)
            if possible_base.processed:
                break
            possible_base.processed = True
            set_inheritance(all_weapons, possible_base)
            break
    return []


@timer
def setup_inheritance_tree(all_weapons):
    top_weapons = generate_top_weapons(all_weapons)
    for weapon in top_weapons:
        set_inheritance(all_weapons, weapon)


@timer
def generate_top_weapons(all_weapons):
    top_weapons = all_weapons.copy()
    print("Generating Top-Level weapons (Will take a long time!)...")
    for weapon in all_weapons:
        print("Processing \"" + weapon.baseClass + "\"...")
        for testWeapon in all_weapons:
            if testWeapon in top_weapons and weapon.inheritClass == testWeapon.baseClass:
                top_weapons.remove(testWeapon)
                break
    return top_weapons


@timer
def read(cfg_weapons):
    class ClassReadState(Enum):
        SEARCHING_FOR_CLASS = 0
        READING_CLASS_NAME = 1
        SEARCHING_END_OF_CLASS = 2

    if 'rhsusf' in cfg_weapons:
        pass

    found_cfg_weapons = False
    total_cfg_weapons = ""
    file = open(cfg_weapons, 'r')
    for line in file:
        if "class cfgweapons" in line.lower():
            found_cfg_weapons = True
        if found_cfg_weapons:
            total_cfg_weapons += line
    file.close()

    all_classes = []
    class_positions = []
    bracket_counter = 0
    count = 0
    read_state = ClassReadState.SEARCHING_FOR_CLASS

    total_cfg_weapons = total_cfg_weapons.replace('\n', '').replace('\r', '').replace('\t', '')

    iteration = len("class cfgweapons")
    wanted_iteration = 0
    found_start = False
    for c in total_cfg_weapons[len("class cfgweapons"):]:
        if c == '{':
            bracket_counter += 1
            found_start = True
        elif c == '}':
            bracket_counter -= 1

        if found_start and bracket_counter == 0:
            break

        if read_state == ClassReadState.SEARCHING_FOR_CLASS:
            if c == "class"[count]:
                count += 1
            else:
                count = 0
            if count >= len("class") - 1:
                count = 0
                read_state = ClassReadState.READING_CLASS_NAME
                wanted_iteration = iteration + 1
        elif read_state == ClassReadState.READING_CLASS_NAME:
            if c == '{':
                class_positions.append([wanted_iteration + 2, 0])
                read_state = ClassReadState.SEARCHING_END_OF_CLASS
            elif c == ';':
                class_positions.append([wanted_iteration + 2, iteration + 1])
                read_state = ClassReadState.SEARCHING_FOR_CLASS
        elif read_state == ClassReadState.SEARCHING_END_OF_CLASS:
            if bracket_counter == 1:
                class_positions[-1][1] = iteration + 1
                read_state = ClassReadState.SEARCHING_FOR_CLASS

        # End of for loop
        iteration += 1

    iteration = 0
    count = 0
    for cp in class_positions:
        weapon_class = total_cfg_weapons[cp[0]:cp[1]]
        new_class = ClassData()

        temp_str = ""
        for c in weapon_class:
            if c == ':' or c == ';':
                temp_str = temp_str.replace('class ', '')
                new_class.baseClass = temp_str.strip()
                temp_str = ""
            elif c == '{':
                new_class.inheritClass = temp_str.strip()
                temp_str = ""
                break
            else:
                temp_str += c
            iteration += 1

        new_class.classDefinition = (total_cfg_weapons[(cp[0] + iteration):cp[1]]).strip()
        iteration = 0
        all_classes.append(new_class)
    return all_classes


def read_config(filepath):
    class ReadState(Enum):
        READING_VALUES = 0
        READING_WEAPONS = 1

    class ModeReadState(Enum):
        READING_COMMENT = 0
        READING_MODE = 1
        READING_MODE_DEF = 2

    config = open(filepath, 'r')
    total_config = ""
    for line in config:
        total_config += line
    config.close()

    mode_str = ""
    reading_mode_data = False
    count = 0
    iteration = 0
    for c in total_config:
        if not reading_mode_data:
            if c == "(modes)"[count]:
                count += 1
            else:
                count = 0;
            if count == len("(modes)"):
                reading_mode_data = True
        else:
            if c == '[' or c == '(':
                break
            else:
                mode_str += c
        iteration += 1

    config_file = ConfigData

    values = []
    weapon_values = []
    reading_value = False
    temp_str = ""
    weapon_value_str = ""

    read_state = ReadState.READING_VALUES
    reading_comment = False
    for c in total_config[iteration:]:
        if not reading_comment:
            if c == '#':
                reading_comment = True
            if read_state == ReadState.READING_VALUES:
                if c == '{':
                    reading_value = True
                elif c == '}':
                    reading_value = False
                    if temp_str:
                        values.append(temp_str.split(','))
                    else:
                        values.append([])
                    temp_str = ""
                elif c == '\n':
                    read_state = ReadState.READING_WEAPONS
                    temp_str = ""
                    reading_value = False
                elif reading_value:
                    temp_str += c

            elif read_state == ReadState.READING_WEAPONS:
                if c == '[':
                    read_state = ReadState.READING_VALUES
                    values = []
                elif c == '=':
                    reading_value = True
                elif c == '\n':
                    if not reading_value:
                        weapon_values = values
                    config_file.add_weapon(config_file, temp_str, weapon_values)
                    weapon_values = []
                    temp_str = ""
                    weapon_value_str = ""
                    reading_value = False
                elif reading_value:
                    if c != '{' and c != '}':
                        weapon_value_str += c
                    elif c == '}':
                        weapon_values.append(weapon_value_str.split(','))
                        weapon_value_str = ""
                else:
                    temp_str += c
        else:
            if c == '\n':
                reading_comment = False

    index = -1
    custom_mode = ""
    custom_mode_def = ""
    mode_state = ModeReadState.READING_MODE
    for c in mode_str[1:]:
        if c == '#':
            mode_state = ModeReadState.READING_COMMENT
        elif c == '\n':
            index += 1
        if mode_state == ModeReadState.READING_MODE:
            if c == '=':
                mode_state = ModeReadState.READING_MODE_DEF
            elif c == '\n':
                if custom_mode:
                    config_file.add_mode(config_file, [custom_mode, custom_mode_def, index])
                custom_mode = ""
                custom_mode_def = ""
            else:
                custom_mode += c
        elif mode_state == ModeReadState.READING_MODE_DEF:
            if c == '}':
                mode_state = ModeReadState.READING_MODE
            custom_mode_def += c
        elif mode_state == ModeReadState.READING_COMMENT:
            if c == '\n':
                mode_state = ModeReadState.READING_MODE

    return config_file


@timer
def main():
    output_file_name = "cfgWeapons.hpp"
    path_to_cfg_weapons = os.path.dirname(sys.argv[0])
    path_to_unpacked_pbos = "E:\Desktop_Files\C++\ARMA_Addons\ARMA2PBOs"

    if len(sys.argv) > 1:
        path_to_unpacked_pbos = sys.argv[1]
    if len(sys.argv) > 2:
        path_to_cfg_weapons = os.path.dirname(sys.argv[2])
    if len(sys.argv) > 3:
        output_file_name = sys.argv[3]

    if not path_to_cfg_weapons:
        print("Error: No path to desired cfgWeapons. Current Path Input: " + path_to_cfg_weapons)
        sys.exit(-1)
    if not path_to_unpacked_pbos:
        print("Error: No path to unpacked PBOs. Current Path Input: " + path_to_unpacked_pbos)
        sys.exit(-1)

    print(path_to_unpacked_pbos)

    path_to_cfg_weapons += "/" + output_file_name

    cfg_weapons = ""

    disallowed_directories = ["001_Omit", "ca\\", "x\\", "CUP_Weapons_ACE_compat"]
    iterations = 0

    config_file = read_config("weapons.txt")

    f = open(path_to_cfg_weapons, 'a')
    f.close()

    all_weapons = []

    for (dirPath, dirNames, fileNames) in os.walk(path_to_unpacked_pbos):
        if not any(substring in dirPath for substring in disallowed_directories):
            for filename in fileNames:
                if filename.lower() == 'config.cpp' or filename.lower() == 'cfgweapons.hpp':
                    print("Reading", dirPath + '/' + filename)
                    all_classes_in_file = read(dirPath + '/' + filename)
                    all_weapons += remove_duplicate_weapons(all_weapons, all_classes_in_file)
                    iterations += 1
                    print("Done!")

    print('Setting Inheritance Tree...')
    setup_inheritance_tree(all_weapons)
    print("Writing to file... (Path: " + path_to_cfg_weapons + ")")
    write_to_file(path_to_cfg_weapons, write_to_string(all_weapons, config_file))
    print("Processed", iterations, "Files")
    print("\n")
    if warnings:
        print("Warnings:")
        for warning in warnings:
            print("\t" + warning)
    else:
        print("Completed with no warnings!")

if __name__ == "__main__":
    main()

